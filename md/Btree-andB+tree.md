# B树、B+树

B树是为实现高效的磁盘存取而设计的 **多叉平衡搜索树**。B树就是B-树，B树的英文名是B-Tree，所以被翻译成B-树（其实是不对的

B+树是B树的一种变形，它更适合实际应用中操作系统的文件索引和数据库索引。

为什么用多叉树呢？

传统的二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，从而导致查询效率低下，因此应该降低树的深度，从而减少磁盘查找存取的次数。所以，一个基本的想法就是：采用多叉树结构（增加一个结点的元素个数）。

磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来，一旦盘块进入内存中，内存中的查询等操作相比磁盘操作的时间可以忽略不计了。而磁盘IO代价主要花费在查找时间上。因此应该尽量将相关信息存放在同一盘块，或者至少放在相邻盘块中，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间。

B树和B+树的一个节点通常存在一个block上（大小相近）。

## B树

这是一颗B树:  

 ![图片](https://raw.githubusercontent.com/julycoding/The-Art-Of-Programming-By-July/master/ebook/images/7/6.jpg)

一个m阶B树有如下性质：

1. 每个结点至多拥有m棵子树；

2. 根结点至少拥有两颗子树（存在子树的情况下）；

3. 除了根结点以外，其余每个分支结点至少拥有 m/2 棵子树；

4. 所有的叶结点都在同一层上；

5. 有k棵子树的分支结点则存在 k-1 个关键码，关键码按照递增次序进行排列；

由此可以看出B的特性: 关键字集合分布在整颗树中，每一个关键字出现且只出现在一个结点中，因此搜索有可能在非叶子结点结束。 

### B树的插入操作

插入元素可能会使B树的层数增加。

插入元素可能会使B树失去原有的性质，所以在插入一个元素之后，还需要将B树调整回去，使B树还满足如下性质：

1. 树中每个节点最多m个孩子，即m满足[m/2]<=M<=m； 

2. 除根节点和叶子节点外，其他每个节点至少[m/2]个孩子； 

3. 除根节点外，（包括叶子节点）节点关键字数n需要满足：[m/2]-1<=n<=m-1；

以下是B树分裂的过程（涉及到节点分裂）：

B树插入操作是将关键字插入已存在的叶节点上。

沿着根节点一直向下查找，找到合适节点插入。若插入后节点已经满了，即（2T阶树节点最多2T-1个关键字），故将n=2T-1分裂为两个T-1个关键子的子节点，同时中间元素（第T个元素）被提升至父节点（插入父节点），若父节点满了，则用相同的方法对父节点进行分裂，一直迭代直到父节点不满出为止。

伪代码：

```
/*
一颗2T阶B树
设插入的元素为key，其有效信息为data
*/
    1. 查找。查找到合适的叶子节点 l，并将元素key和data插入该叶子节点 l。 
    2. 令节点 n = l 
        a. 如果 n 中元素个数小于 2T-1，无需分裂，插入完成，函数返回；否则，执行 b
        b. 将 节点 n 分裂 ：
            b1. middle = 节点 n 的的中间元素，将middle插入到节点 n 的父节点 p 的相应位置
            b2. middle元素的左子树指向 原节点 n 中middle前面的部分
            b3. middle元素的左子树指向 原节点 n 中middle后面的部分 
        c. n = p  ( 分裂后将父节点p 设为当前节点 ) 继续 a 
```

### B树的删除操作

删除元素可能会使B树的层数降低。 

删除元素可能会使B树失去原有的性质，所以在删除一个元素之后，还需要将B树调整回去，使B树还满足之前的性质。

B树的删除操作比插入稍微复杂一些，因为元素可以从 **任意节点** 中删除。(插入元素只能插入在叶子节点)

B树删除节点伪代码（包含合并）：

```
/*
一颗2T阶B树
设删除的元素为key
*/
    1. 查找。查找到key所在的节点 l ，如果节点 l是非叶子节点，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key，
    然后在后继key所在的子树中删除该后继key。（就是用key的后继元素代替当前元素 key）
    2. 令节点 n = l
        a. 如果 n 中元素个数大于等于 T-1，无需合并，删除完成，函数返回；否则，执行 b 
        b. 合并节点：
            b1. o = n 的兄弟节点 （当前节点的兄弟节点，可以是左兄弟，也可以是右兄弟）
            b2. o节点中元素个数大于 T-1（兄弟节点有富余的元素），则将父节点 p 中一个元素移到（下降）当前节点 n， 将兄弟节点o 中的一个元素移到（上升）到父节点 p。
            （当前节点向父节点借一个，父节点向兄弟节点借一个，之所以这样移动，是为了保持有序性，有没有觉得这个操作很像红黑树中左右旋！）
            b3. o节点中元素个数等于 T-1（兄弟节点没有富余的元素），则将父节点 p 中一个元素移到（下降）当前节点 n，合并兄弟节点 o 和 当前节点 n为一个节点。
            （兄弟节点元素为T-1，当前节点元素个数为T-2，加上从父节点得来的一个元素，合并后元素的个数为2T-1）
        c. n = p ( (分裂后将父节点p 设为当前节点 ) 继续 a ) 
```


## B+树

这是一颗B+树：

![图片](https://raw.githubusercontent.com/yuyilei/Algorithms/master/picture/B%2Btree.png)

B+树是B树的变型，异同点在于：

1. 相同点：有 k 棵子树的分支节点有 k-1 个关键码。 

2. 不同点：所有叶子节点包含全部关键字信息，及指向含有这些关键字记录的指针。且叶子结点本身依关键字的大小自小而大的顺序链（即叶子节点有指向兄弟节点的指针，将所有的叶子节点连接成一个有序的链）。

3. 不同点：**所有的非叶子结点可以看成是索引部分**，结点中仅含有其子树根结点中最大（或最小）关键字，并没有要查找的有效信息。 (而B树的非叶子节点也包含需要查找的有效信息)。 所以B+的某些元素会出现两次（分别在叶子节点和非叶子节点），但是B树的所有的节点均只出现一次。 

### B+树插入节点 

B+树的插入节点与B树相似，略有不同，伪代码：

```
/*
一颗2T阶B+树
设插入的元素为key，其有效信息为data
*/
    1. 查找。查找到合适的叶子节点 l，并将元素key和data插入该叶子节点 l。 
    2. 令节点 n = l 
        a. 如果 n 中元素个数小于 2T-1，无需分裂，插入完成，函数返回；否则，执行 b
        b. 将 节点 n 分裂 ：
            b1. middle = 节点 n 的的中间元素，将middle插入到节点 n 的父节点 p 的相应位置
            b2. middle元素的左子树指向 原节点 n 中middle及节点 middle 前面的部分
            b3. middle元素的左子树指向 原节点 n 中middle后面的部分 
        c. n = p  ( 分裂后将父节点p 设为当前节点 ) 继续 a 
```

与B树不同的是，在B+树插入时，如果需要分裂节点，那个上升到父节点的的元素（也就是上面的middle）也要被分配到 分裂后的两个节点中的一个（左右任选，上文选择的是左节点）。

### B+树删除节点 

B+树的删除节点与B树相似，略有不同，伪代码： 

```
/*
一颗2T阶B树
设删除的元素为key
*/
    1. 查找。查找到key所在的节点 l ，如果节点 l是非叶子节点，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key，
    然后在后继key所在的子树中删除该后继key。（就是用key的后继元素代替当前元素 key）
    2. 令节点 n = l
        a. 如果 n 中元素个数大于等于 T-1，无需合并，删除完成，函数返回；否则，执行 b 
        b. 处理节点：
            b1. o = n 的兄弟节点 （当前节点的兄弟节点，可以是左兄弟，也可以是右兄弟）
            b2. o节点中元素个数大于 T-1（兄弟节点有富余的元素），则将兄弟节点 o 中的一个元素移到 当前节点 n，并用这个从兄弟节点借来的元素 替代父节点p 中的相应元素。
            （兄弟节点中的一个元素 借给 当前节点，并用这个元素 替换父节点中的相应元素，是替换!）
            b3. o节点中元素个数等于 T-1（兄弟节点没有富余的元素），当前结点 n 和兄弟结点 o 合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点 n 指向父结点 p，有以下三种情况：
                b31: n 中元素个数大于等于 T-1，无需合并，删除完成，函数返回。
                b32: n 中元素个数小于 T-1，且兄弟节点有富余，则父结点中一个元素 下移，兄弟结点中一个元素 上移，删除结束，函数返回，
                b33: n 中元素个数小于 T-1，且兄弟节点没有富余，当前结点 n 和兄弟结点 o 及父结点下移的一个元素合并成一个新的结点。将当前结点n 指向父结点 p ，重复b31。
```

注意，通过B+树的删除操作后，非叶子结点中存在的key，不一定在叶子结点中存在对应的记录。


### B树与B+树的比较

1. B+树 比B 树更适合实际应用中操作系统的文件索引和数据库索引——B+树的磁盘读写代价更低 

B+树的非叶子结点并没有关键字具体信息。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

假设磁盘中的一个盘块容纳16b，而一个关键字2b，一个关键字具体信息2b。一棵9阶B树(一个结点最多8个关键字)的非叶子结点需要2个盘块。而B+ 非叶子结点只需要1个盘块（非叶子节点不需要存关键字信息）。当需要把非叶子结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间。

2. B+树的查询效率更加稳定

B+树非叶子节点并不存关键字信息，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

总而言之，B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题（在B树中遍历所有关键字需要遍历整棵树）。正是为了解决这个问题，B+树应运而生。

B+树只要遍历叶子节点就可以实现整棵树的遍历(叶子节点上有所有关键字)，支持基于范围的查询，而B树不支持range-query这样的操作，或者说效率太低，因为逻辑上相邻的两个关键字，用B树存储可能物理距离很远（可能位于父子节点上，在两个不同的盘块中）,而B+树中关键字逻辑位置和物理位置一致（都在叶子节点上，且叶子节点有序）。

所以，B+树更适合实际应用中操作系统的文件索引和数据库索引，而事实上，更多的数据库都是采用B+树。



